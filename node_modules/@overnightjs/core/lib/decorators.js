"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
require("reflect-metadata");
function Checkout(path) {
    return helperForRoutes('checkout', path);
}
exports.Checkout = Checkout;
function Copy(path) {
    return helperForRoutes('copy', path);
}
exports.Copy = Copy;
function Delete(path) {
    return helperForRoutes('delete', path);
}
exports.Delete = Delete;
function Get(path) {
    return helperForRoutes('get', path);
}
exports.Get = Get;
function Head(path) {
    return helperForRoutes('head', path);
}
exports.Head = Head;
function Lock(path) {
    return helperForRoutes('lock', path);
}
exports.Lock = Lock;
function Merge(path) {
    return helperForRoutes('merge', path);
}
exports.Merge = Merge;
function Mkactivity(path) {
    return helperForRoutes('mkactivity', path);
}
exports.Mkactivity = Mkactivity;
function Mkcol(path) {
    return helperForRoutes('mkcol', path);
}
exports.Mkcol = Mkcol;
function Move(path) {
    return helperForRoutes('move', path);
}
exports.Move = Move;
function MSearch(path) {
    return helperForRoutes('m-search', path);
}
exports.MSearch = MSearch;
function Notify(path) {
    return helperForRoutes('notify', path);
}
exports.Notify = Notify;
function Options(path) {
    return helperForRoutes('options', path);
}
exports.Options = Options;
function Patch(path) {
    return helperForRoutes('patch', path);
}
exports.Patch = Patch;
function Post(path) {
    return helperForRoutes('post', path);
}
exports.Post = Post;
function Purge(path) {
    return helperForRoutes('purge', path);
}
exports.Purge = Purge;
function Put(path) {
    return helperForRoutes('put', path);
}
exports.Put = Put;
function Report(path) {
    return helperForRoutes('report', path);
}
exports.Report = Report;
function Search(path) {
    return helperForRoutes('search', path);
}
exports.Search = Search;
function Subscribe(path) {
    return helperForRoutes('subscribe', path);
}
exports.Subscribe = Subscribe;
function Trace(path) {
    return helperForRoutes('trace', path);
}
exports.Trace = Trace;
function Unlock(path) {
    return helperForRoutes('unlock', path);
}
exports.Unlock = Unlock;
function Unsubscribe(path) {
    return helperForRoutes('unsubscribe', path);
}
exports.Unsubscribe = Unsubscribe;
function helperForRoutes(httpVerb, path) {
    return function (target, propertyKey, descriptor) {
        var routeProperties = Reflect.getOwnMetadata(propertyKey, target);
        if (!routeProperties) {
            routeProperties = {};
        }
        routeProperties = tslib_1.__assign({ httpVerb: httpVerb }, routeProperties);
        if (path === undefined) {
            routeProperties.path = '';
        }
        else if (path instanceof RegExp) {
            if (path.toString().charAt(1) === '^') {
                routeProperties.path = new RegExp('/' + path.toString().slice(2).replace(/\/$/, ''));
            }
            else {
                routeProperties.path = new RegExp('/.*' + path.toString().slice(1).replace(/\/$/, ''));
            }
        }
        else {
            routeProperties.path = '/' + path;
        }
        Reflect.defineMetadata(propertyKey, routeProperties, target);
        if (descriptor) {
            return descriptor;
        }
    };
}
var ClassKeys;
(function (ClassKeys) {
    ClassKeys["BasePath"] = "BASE_PATH";
    ClassKeys["Middleware"] = "MIDDLEWARE";
    ClassKeys["ErrorMiddleware"] = "ERROR_MIDDLEWARE";
    ClassKeys["Wrapper"] = "WRAPPER";
    ClassKeys["Children"] = "CHILDREN";
    ClassKeys["Options"] = "OPTIONS";
})(ClassKeys = exports.ClassKeys || (exports.ClassKeys = {}));
function Controller(path) {
    return function (target) {
        Reflect.defineMetadata(ClassKeys.BasePath, '/' + path, target.prototype);
        return target;
    };
}
exports.Controller = Controller;
function ClassMiddleware(middleware) {
    return function (target) {
        Reflect.defineMetadata(ClassKeys.Middleware, middleware, target.prototype);
        return target;
    };
}
exports.ClassMiddleware = ClassMiddleware;
function ClassErrorMiddleware(middleware) {
    return function (target) {
        Reflect.defineMetadata(ClassKeys.ErrorMiddleware, middleware, target.prototype);
        return target;
    };
}
exports.ClassErrorMiddleware = ClassErrorMiddleware;
function ClassWrapper(wrapperFunction) {
    return function (target) {
        Reflect.defineMetadata(ClassKeys.Wrapper, wrapperFunction, target.prototype);
        return target;
    };
}
exports.ClassWrapper = ClassWrapper;
function ClassOptions(options) {
    return function (target) {
        Reflect.defineMetadata(ClassKeys.Options, options, target.prototype);
        return target;
    };
}
exports.ClassOptions = ClassOptions;
function Children(controllers) {
    console.log('Warning: @Children decorator is deprecated. Use ChildControllers instead.');
    return function (target) {
        Reflect.defineMetadata(ClassKeys.Children, controllers, target.prototype);
        return target;
    };
}
exports.Children = Children;
function ChildControllers(controllers) {
    return function (target) {
        Reflect.defineMetadata(ClassKeys.Children, controllers, target.prototype);
        return target;
    };
}
exports.ChildControllers = ChildControllers;
function Middleware(middleware) {
    return function (target, propertyKey, descriptor) {
        var routeProperties = Reflect.getOwnMetadata(propertyKey, target);
        if (!routeProperties) {
            routeProperties = {};
        }
        routeProperties = tslib_1.__assign({ routeMiddleware: middleware }, routeProperties);
        Reflect.defineMetadata(propertyKey, routeProperties, target);
        if (descriptor) {
            return descriptor;
        }
    };
}
exports.Middleware = Middleware;
function ErrorMiddleware(middleware) {
    return function (target, propertyKey, descriptor) {
        var routeProperties = Reflect.getOwnMetadata(propertyKey, target);
        if (!routeProperties) {
            routeProperties = {};
        }
        routeProperties = tslib_1.__assign({ routeErrorMiddleware: middleware }, routeProperties);
        Reflect.defineMetadata(propertyKey, routeProperties, target);
        if (descriptor) {
            return descriptor;
        }
    };
}
exports.ErrorMiddleware = ErrorMiddleware;
function Wrapper(wrapperFunction) {
    return function (target, propertyKey, descriptor) {
        var routeProperties = Reflect.getOwnMetadata(propertyKey, target);
        if (!routeProperties) {
            routeProperties = {};
        }
        routeProperties = tslib_1.__assign({ routeWrapper: wrapperFunction }, routeProperties);
        Reflect.defineMetadata(propertyKey, routeProperties, target);
        if (descriptor) {
            return descriptor;
        }
    };
}
exports.Wrapper = Wrapper;
//# sourceMappingURL=decorators.js.map